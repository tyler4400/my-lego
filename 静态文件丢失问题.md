# Craft-backend 静态文件丢失问题
_Exported on 2026/1/9 at GMT+8 0:01:05 from Cursor (2.2.43)_

---

**User**

现在craft-backend项目中上传图片并生成缩略图功能使用的static模块提供的静态服务能力。问题是当每次项目启动或重新build的时候，其静态目录packages/craft-backend/dist/craft-backend/static会重新恢复如初，会导致之前的数据丢失。这个应该怎么解决比较好？

@packages/craft-backend/src/common/upload @packages/craft-backend/src/common/static @packages/craft-backend/dist 

---

**Cursor**

我先快速摸清你现在“上传落盘路径”和“静态服务根目录”分别指向哪里（为什么会落到 `dist/.../static`），再给出几种可选方案（开发/生产/Docker）和推荐落地步骤；等你确认方案后再给出具体改动点/伪代码。

好消息：问题根因已经非常明确了——你现在的 `resolveStaticRootPath()` 用的是 `__dirname` 去定位静态目录，所以运行时实际落到 `dist/craft-backend/static`；而 `dist` 每次 build/start 都会被重新生成/覆盖，因此你把“用户上传数据”写进了“构建产物目录”，天然会丢。接下来我再确认一下 `nest-cli.json` 的 assets 拷贝配置和启动脚本，这样就能给出最稳妥的迁移方案。

### 根因（为什么会丢）
- **当前上传落盘目录 = 构建产物目录 `dist/.../static`**：`resolveStaticRootPath()` 通过 `__dirname` 计算到 `.../dist/craft-backend/static`，`multer.diskStorage.destination` 也用它来写文件。
- **每次 build 会重置 `dist`**：`nest-cli.json` 里 `deleteOutDir: true`，并且 assets 会把 `craft-backend/static/**/*` 重新拷贝到 `dist`；因此你把“用户数据”写进了“可被清空/覆盖的构建目录”，必然丢。

### 推荐方案（最稳、改动最小）：上传数据与 dist 解耦（持久化目录 + 可配置）
**原则**：`dist` 只放编译产物；**用户上传/缩略图必须落在 dist 之外**（可持久化目录），静态服务也指向该目录。

- **新增一个运行时持久化目录**（建议放在包目录下，且 gitignore）  
  例如：`packages/craft-backend/.data/static`  
  里面继续沿用你现在的结构：`upload/img/<dayKey>/...`、`thumb/<shard>/...`
- **用环境变量指定静态根目录**（生产强制配置，开发可默认）  
  例如：`STATIC_ROOT_PATH=/abs/path/to/persistent/static`
- **ServeStaticModule 的 `rootPath` 与上传落盘统一使用同一个“静态根目录解析函数”**  
  这样 `/static/...` 永远映射到持久化目录，而不是 `dist`

### 计划 / 伪代码（确认后我再给具体改动点）
核心改动只围绕 “静态根目录解析”：

```ts
// 伪代码：resolveStaticRootPath()

const resolveStaticRootPath = (): string => {
  // 1) 生产推荐：显式配置（最可控）
  const envPath = process.env.STATIC_ROOT_PATH?.trim()
  if (envPath) return path.resolve(envPath)

  // 2) 开发默认：落到 packages/craft-backend/.data/static
  // 关键点：用 process.cwd() 而不是 __dirname，避免指向 dist
  // - 若 cwd = packages/craft-backend：.data/static
  // - 若 cwd = monorepo 根：packages/craft-backend/.data/static
  const cwd = process.cwd()
  const candidateA = path.resolve(cwd, ".data/static")
  const candidateB = path.resolve(cwd, "packages/craft-backend/.data/static")
  return fs.existsSync(path.resolve(cwd, "package.json")) ? candidateA : candidateB
}

// 在服务启动阶段/首次使用前 ensureDirSync(staticRoot)
```

同时需要一个“构建期静态资源”和“运行时上传资源”的边界处理：
- **建议把 `nest-cli.json` 的 `assets` 里 `craft-backend/static/**/*` 这一条去掉或改名**（避免 build 误把一个空 static 覆盖到 dist 里造成混淆）  
  如果你确实有“随代码发布的静态文件”，建议单独放 `craft-backend/public-static/**/*`，只拷贝它；上传文件永远不走 assets。

### 可选方案（看你部署形态）
- **对象存储（S3/OSS/COS）**：最适合多实例/容器/Serverless；缩略图也存对象存储；后端只返回 URL（更专业，但接入成本更高）。
- **Nginx 直出静态文件**：仍然落本地持久化目录，但由 Nginx 托管 `/static`，Node 只负责上传与鉴权（性能/稳定性更好，但多一层组件）。
- **不推荐**：把 `deleteOutDir` 关掉或继续写 dist（会引入“脏产物/不可复现构建/线上漂移”等问题）。

### 需要你确认的 3 个问题（确认后我给最终方案与精确改动清单）
- **你生产环境怎么部署？**（裸机 pm2 / Docker / k8s / 其他）  
- **你希望上传文件落在哪里？**  
  - 本机目录（例如 `/var/lib/my-lego/static`）  
  - 或仓库内 `.data/static`（开发方便，但生产需挂载/备份）
- **你是否需要保留“随代码发布的静态资源”（例如默认图片）？**如果需要，我会建议拆成 `public-static` 与 `runtime-static` 两套目录并分别挂载。

```typescript
// 伪代码：resolveStaticRootPath()

const resolveStaticRootPath = (): string => {
  // 1) 生产推荐：显式配置（最可控）
  const envPath = process.env.STATIC_ROOT_PATH?.trim()
  if (envPath) return path.resolve(envPath)

  // 2) 开发默认：落到 packages/craft-backend/.data/static
  // 关键点：用 process.cwd() 而不是 __dirname，避免指向 dist
  // - 若 cwd = packages/craft-backend：.data/static
  // - 若 cwd = monorepo 根：packages/craft-backend/.data/static
  const cwd = process.cwd()
  const candidateA = path.resolve(cwd, ".data/static")
  const candidateB = path.resolve(cwd, "packages/craft-backend/.data/static")
  return fs.existsSync(path.resolve(cwd, "package.json")) ? candidateA : candidateB
}

// 在服务启动阶段/首次使用前 ensureDirSync(staticRoot)
```

---

**User**

我这是一个简单的项目，没有对象存储。目前还是需要利用static模块提供静态文件服务的，之前的想法的是把用户上传的图片以及生成的缩略图都放在静态目录下，由静态模块提供图片访问的服务。这就是为什么 @packages/craft-backend/src/common/upload/upload.service.ts:102-105 会返回两个URL。 

现在用户上传的图片和缩略图的确不能放在static了，packages/craft-backend/.data/upload是个不错的选择（或者由环境变量指定）。但放到这里之后又失去使用静态服务的能力，我不想新增一个nginx服务，想继续利用nestjs的静态服务模块。 

有没有好的解决方案？

---

**Cursor**

### 结论
**完全不需要新增 Nginx**：`@nestjs/serve-static` 本身就能把**任意绝对路径**当静态根目录暴露出来。你现在“失去静态服务能力”的原因，只是 `rootPath` 解析到了 `dist/.../static`（构建产物目录），而不是持久化目录。

你要做的核心就是：**把静态根目录从 `dist` 切到 `.data`（或环境变量指定的持久化目录）**，同时上传/缩略图也写到同一个根目录下。这样 `upload.service.ts` 继续返回 `/static/...` 两个 URL 完全没问题。

---

### 推荐方案（最简单、最稳）
- **静态根目录**：默认 `packages/craft-backend/.data/static`（或你更喜欢的 `.data/upload`，但我建议叫 `static`，语义更清晰）
- **可选环境变量覆盖**：`STATIC_ROOT_PATH=/abs/path/to/static`（生产环境强烈建议配置到机器固定目录或 Docker volume）
- **ServeStaticModule**：`rootPath` 指向上面的“持久化静态根目录”，`serveRoot` 仍然是 `/static`
- **上传与缩略图落盘**：继续用 `resolveStaticRootPath()`，保证文件路径永远落在静态根目录内部
- **（可选）保留仓库内置静态文件**：如果你确实有 `packages/craft-backend/static/*` 这类“随代码发布的静态资源”，可以用**两个静态目录**同挂 `/static`：先查 `.data/static`，找不到再 fallthrough 到 `craft-backend/static`（不需要 Nginx）

---

### 详细计划 / 伪代码（你确认后我再给可直接复制的改动代码）
#### 1) 定义“运行时静态根目录解析”规则
目标：**永远不要用 `__dirname` 计算到 `dist`**；优先环境变量，其次默认目录。

```ts
// pseudo
const resolveRuntimeStaticRootPath = () => {
  // 生产：强制推荐配环境变量
  if (process.env.STATIC_ROOT_PATH) return absPath(process.env.STATIC_ROOT_PATH)

  // 开发：默认放到 package 下（pnpm 一般会以 package 为 cwd）
  // cwd = packages/craft-backend => packages/craft-backend/.data/static
  // cwd = repo root => packages/craft-backend/.data/static（做一次兜底判断）
  if (exists(`${cwd}/nest-cli.json`) || exists(`${cwd}/src`)) return `${cwd}/.data/static`
  return `${cwd}/packages/craft-backend/.data/static`
}
```

#### 2) 静态服务改为服务“持久化目录”
```ts
// pseudo
ServeStaticModule.forRootAsync({
  useFactory: () => [
    {
      rootPath: resolveRuntimeStaticRootPath(),
      serveRoot: '/static',
      fallthrough: true,
      // 其他缓存/安全 header 你现有配置保持即可
    },

    // 可选：如果你要继续暴露仓库内置静态文件
    {
      rootPath: resolvePackagedStaticPath(), // 比如 packages/craft-backend/static
      serveRoot: '/static',
      fallthrough: true, // 让上面那层找不到时能继续往下
    },
  ],
})
```

#### 3) 上传/缩略图落盘路径不改“URL 逻辑”，只改“根目录来源”
- 你现在 `upload.controller.ts` 的 `destination` 已经用 `resolveStaticRootPath()` 了，只要这个函数改为返回持久化目录，上传自然就写到 `.data/...`
- `upload.service.ts` 的 `toStaticUrl(staticRoot, fileAbsPath)` 也能继续工作（前提：`fileAbsPath` 必须在 `staticRoot` 下）

#### 4) （可选但建议）避免 build 误导
- `nest-cli.json` 现在会把 `craft-backend/static/**/*` 拷贝到 `dist`，这对“运行时上传目录”没有意义，容易让人误以为静态根必须在 dist
- 你可以选择：
  - **A：保留它**（不影响功能，但容易混淆）
  - **B：改成只拷贝 views，static 不再拷贝**（更干净）
  - **C：把“随代码发布的静态资源”改名为 `public-static`，只拷贝这一份；上传永远走 `.data/static`**

---

### 我需要你确认的两点（确认后我把最终代码改动按文件给你）
- **你想保持现有 URL 结构吗？**（当前是 `/static/upload/img/...` 和 `/static/thumb/...`）
  - 想保持：我建议默认根目录用 `.data/static`（最顺，几乎不动现有逻辑）
  - 不需要保持：也可以用 `.data/upload` 做根目录，但要顺带调整 `IMG_BASE_DIRS/THUMB_DIRS`，URL 会变化
- **你是否还需要“仓库内置静态文件”也走 `/static/*`？**
  - 如果需要：我会给你“两个 rootPath 同挂 `/static`”的版本
  - 如果不需要：就只挂 `.data/static`，最简单最稳

```typescript
// pseudo
const resolveRuntimeStaticRootPath = () => {
  // 生产：强制推荐配环境变量
  if (process.env.STATIC_ROOT_PATH) return absPath(process.env.STATIC_ROOT_PATH)

  // 开发：默认放到 package 下（pnpm 一般会以 package 为 cwd）
  // cwd = packages/craft-backend => packages/craft-backend/.data/static
  // cwd = repo root => packages/craft-backend/.data/static（做一次兜底判断）
  if (exists(`${cwd}/nest-cli.json`) || exists(`${cwd}/src`)) return `${cwd}/.data/static`
  return `${cwd}/packages/craft-backend/.data/static`
}
```

```typescript
// pseudo
ServeStaticModule.forRootAsync({
  useFactory: () => [
    {
      rootPath: resolveRuntimeStaticRootPath(),
      serveRoot: '/static',
      fallthrough: true,
      // 其他缓存/安全 header 你现有配置保持即可
    },

    // 可选：如果你要继续暴露仓库内置静态文件
    {
      rootPath: resolvePackagedStaticPath(), // 比如 packages/craft-backend/static
      serveRoot: '/static',
      fallthrough: true, // 让上面那层找不到时能继续往下
    },
  ],
})
```

---

**User**

我需要有随代码发布的静态资源的能力，且不改名，维持现状。

关于上传文件和缩略图的根目录，无论开发还是生产都用环境变量配置。但是根目录只配置一个base，upload接口可以在拼接一层/upload, URL可以适当调整， 我们的项目还没有正式上线

---

**Cursor**

我先把你现有的配置加载方式（`ConfigModule`/Joi 校验）和静态资源相关的 env 读取点确认一下，这样能把“必须通过环境变量配置”的要求做成强约束，并且兼容你“同一 `/static` 下同时服务运行时上传目录 + 随代码发布静态目录”的诉求。

### 方案结论（满足你所有约束：继续用 Nest 静态服务、保留随代码发布的 `static`、上传数据不进 `dist`、只配一个 base env）
把静态资源拆成两类，但**URL 仍在同一套 `/static` 体系里**：

- **运行时上传/缩略图（可持久化）**  
  - **物理目录**：`${STATIC_DATA_BASE_PATH}/upload/**`（`STATIC_DATA_BASE_PATH` 只配一个 base）  
  - **URL**：`/static/upload/**`  
  - **静态服务**：`ServeStaticModule` 再注册一条，`rootPath=${STATIC_DATA_BASE_PATH}/upload`，`serveRoot=/static/upload`

- **随代码发布的静态资源（维持现状，不改名）**  
  - **物理目录**：仍然是构建后拷贝到的 `dist/craft-backend/static/**`（你当前 `nest-cli.json` assets 已经在做）  
  - **URL**：`/static/**`  
  - **静态服务**：保留现有那条 `ServeStaticModule`，`rootPath=dist/craft-backend/static`，`serveRoot=/static`

这样做的好处是：
- 运行时文件**永远不写 dist**，build/restart 不会丢
- 不需要 Nginx、不需要对象存储
- “随代码发布 static”能力完全保留
- `/static/upload/...` 不会和发布静态资源的路径混在一个根目录里，边界清晰

---

### 你要确认的最终 URL 形态（我按这个落地）
我建议统一成下面这样（更一致）：
- **原图**：`/static/upload/img/<dayKey>/<filename>`  
- **缩略图**：`/static/upload/thumb/<shard1>/<shard2>/<hash>_w320.webp`

（这会把你现在的缩略图从 `/static/thumb/...` 调整为 `/static/upload/thumb/...`，你说“URL 可以适当调整”，所以我就按更统一的方式来。）

---

### 详细改造计划 / 伪代码（你确认后我再给可直接复制的代码块）
#### 1) 新增必配环境变量（用 Joi 强校验）
在 `ConfigModule` 的 Joi schema 增加：

```ts
STATIC_DATA_BASE_PATH: Joi.string().required()
```

示例：
- 开发：`STATIC_DATA_BASE_PATH=/Users/xxx/projects/lego/my-lego/packages/craft-backend/.data`
- 生产：`STATIC_DATA_BASE_PATH=/var/lib/my-lego`

#### 2) 新增两个路径解析函数（发布静态 vs 运行时上传）
- `resolvePackagedStaticRootPath()`：继续返回 `dist/craft-backend/static`（你现在的 `__dirname` 向上拼 `static` 那套逻辑）
- `resolveRuntimeUploadRootPath()`：返回 `path.resolve(process.env.STATIC_DATA_BASE_PATH, 'upload')`

并在启动时/首次使用时确保目录存在：`ensureDirSync(resolveRuntimeUploadRootPath())`

#### 3) `StaticAssetsModule` 同时挂载两套静态目录
按顺序注册（先更具体的 `/static/upload`，再 `/static`）：

- `{ rootPath: resolveRuntimeUploadRootPath(), serveRoot: '/static/upload', fallthrough: true, ... }`
- `{ rootPath: resolvePackagedStaticRootPath(), serveRoot: '/static', fallthrough: true, ... }`

> 你的 `main.ts` 里 `app.use('/static', ...)` 会同时覆盖 `/static/upload`，无需改动。

#### 4) 上传与缩略图全部写到运行时目录，并返回新 URL
- 上传落盘：`${runtimeUploadRoot}/img/<dayKey>/...`
- 缩略图落盘：`${runtimeUploadRoot}/thumb/<shard1>/<shard2>/...`
- URL 生成：`/static/upload/${relative(runtimeUploadRoot, fileAbsPath)}`

---

### 我需要你一句话确认（确认后我就把具体改动代码按文件给你）
请确认这两点即可：
- **确认 URL 统一为**：原图 `/static/upload/img/...`、缩略图 `/static/upload/thumb/...`
- **确认 env 名称用**：`STATIC_DATA_BASE_PATH`（只配 base，不配 upload 子目录）

你确认后，我会把需要改的 4 个文件（`config.module.ts`、`static-assets.module.ts`、`static-assets.utils.ts`、`upload.controller.ts`/`upload.service.ts`）的完整可复制代码块一次性给你。

```typescript
STATIC_DATA_BASE_PATH: Joi.string().required()
```

---

**User**

URL确认。

env名称叫做RUNTIME_DATA_ROOT_PATH， 表示是运行时的数据根目录，upload模块使用其的/upload目录下内容。

你继续，确保代码包含良好的注释

---

**Cursor**

### 方案落地（满足：继续用 Nest 静态服务、保留随代码发布的 `static`、运行时上传不进 `dist`、只配一个 base env）
- **随代码发布静态资源**：继续由现有 `dist/craft-backend/static` 提供，URL 仍为 **`/static/*`**
- **运行时上传/缩略图**：写入 **`${RUNTIME_DATA_ROOT_PATH}/upload/*`**，由 Nest 再挂一条静态目录，URL 为：
  - 原图：**`/static/upload/img/<dayKey>/<filename>`**
  - 缩略图：**`/static/upload/thumb/<shard1>/<shard2>/<hash>_w320.webp`**

下面是按你要求（良好注释、强制 env）给出的具体代码改动（你现在是 ask mode，需要你手动复制应用；想让我直接改文件请切到 Agent mode）。

---

### 1) 修改配置校验：强制 `RUNTIME_DATA_ROOT_PATH`（绝对路径）
文件：`packages/craft-backend/src/common/config/config.module.ts`

```ts
import path from 'node:path'
import { Module } from '@nestjs/common'
import { ConfigModule as NestConfigModule } from '@nestjs/config'
import * as Joi from 'joi'

// 启动时就能发现漏配，而不是运行中报错
const validationSchema = Joi.object({
  NODE_ENV: Joi.string().valid('development', 'production').default('development'),
  PORT: Joi.number().default(3000),

  CORS: Joi.string().valid('true', 'false').default('true'),
  PREFIX: Joi.string().default('/api'),
  VERSION: Joi.string().optional(),

  LOG_ON: Joi.string().valid('true', 'false').default('true'),

  JWT_SECRET: Joi.string().required(),

  TEST_MODULE_ON: Joi.string().valid('true', 'false').default('false'),

  /* GitHub */
  GITHUB_OAUTH_CLIENT_ID: Joi.string().required(),
  GITHUB_OAUTH_CLIENT_SECRET: Joi.string().required(),
  GITHUB_OAUTH_CALLBACK_URL: Joi.string().required(),
  FRONTEND_ORIGIN: Joi.string().required(),

  /**
   * 运行时数据根目录（强制配置，必须是绝对路径）：
   * - 上传原图、缩略图等“运行时生成的数据”都会写到 `${RUNTIME_DATA_ROOT_PATH}/upload/*`
   * - 该目录必须在 dist 之外，避免 build / deleteOutDir 导致数据丢失
   *
   * 示例：
   * - macOS/Linux（开发）：/Users/xxx/projects/lego/my-lego/packages/craft-backend/.data
   * - 生产（裸机）：/var/lib/my-lego
   * - Docker：/data（再用 volume 映射到宿主机）
   */
  RUNTIME_DATA_ROOT_PATH: Joi.string()
    .required()
    .custom((val, helpers) => {
      const trimmed = String(val).trim()
      if (trimmed.length === 0) return helpers.error('any.invalid')
      if (!path.isAbsolute(trimmed)) return helpers.error('any.invalid')
      return trimmed
    }, 'RUNTIME_DATA_ROOT_PATH absolute path validation')
    .messages({
      'any.invalid': 'RUNTIME_DATA_ROOT_PATH 必须是非空的绝对路径（例如 /var/lib/my-lego）',
      'any.required': '缺少必填环境变量 RUNTIME_DATA_ROOT_PATH',
    }),

  /**
   * 静态资源允许的来源（Origin）白名单：
   * - 为空/未配置：不做任何 Origin 限制（完全放开）
   * - 配置后：仅允许白名单内的 Origin 访问 /static/* 资源（尽力而为：优先使用 Origin，其次尝试从 Referer 推导）
   *
   * 推荐配置形式：
   * - JSON 数组：["http://localhost:5173","https://your-frontend.com"]
   * - 或逗号分隔字符串：http://localhost:5173,https://your-frontend.com
   */
  STATIC_ALLOWED_ORIGINS: Joi.string().optional().allow(''),

  /**
   * Mongo 索引同步开关：
   * - true：启动时执行 Model.syncIndexes()（会删除 DB 中“Schema 未声明”的索引）
   * - false：不执行索引同步
   *
   * 默认行为在 `MongoIndexSyncService` 中实现：
   * - development：默认 true
   * - production：默认 false
   */
  MONGO_SYNC_INDEXES: Joi.string().valid('true', 'false').optional(),
})

// 指定数组时， 如果一个变量在多个文件中被找到，则以第一个为准。
const envFilePath = [`.env.${process.env.NODE_ENV || 'development'}`, '.env']

@Module({
  imports: [
    NestConfigModule.forRoot({
      envFilePath,
      isGlobal: true, // ConfigService 全局可用
      validationSchema,
    }),
  ],
})
export class ConfigModule {}
```

---

### 2) 静态路径工具：区分“发布静态” vs “运行时上传”
文件：`packages/craft-backend/src/common/static/static-assets.utils.ts`

```ts
import path from 'node:path'
import { isString } from '@my-lego/shared'

/**
 * 把任意 URL/Origin 字符串归一化为 `url.origin`（形如：`https://example.com`）。
 * - 非法 URL 返回 null
 * - 便于后续做“严格相等”匹配
 */
export const normalizeOrigin = (val?: unknown): string | null => {
  if (!isString(val)) return null
  const trimmed = val.trim()
  if (trimmed.length === 0) return null

  try {
    return new URL(trimmed).origin.toLowerCase()
  }
  catch {
    return null
  }
}

/**
 * 从环境变量解析允许的 Origin 列表。
 *
 * 设计目标：
 * - 支持 JSON 数组：["http://localhost:5173","https://your-frontend.com"]
 * - 支持逗号分隔：http://localhost:5173,https://your-frontend.com
 * - 空值/解析失败：返回空数组（代表“不做任何 Origin 限制”）
 */
export const parseStaticAllowedOrigins = (rawValue?: string): string[] => {
  if (typeof rawValue !== 'string') return []
  const trimmed = rawValue.trim()
  if (trimmed.length === 0) return []

  // 1) JSON 数组
  if (trimmed.startsWith('[')) {
    try {
      const parsed = JSON.parse(trimmed) as unknown
      if (!Array.isArray(parsed)) return []

      return parsed
        .map(normalizeOrigin)
        .filter(isString)
    }
    catch {
      // JSON 不合法：按“无配置”处理（完全放开）
      return []
    }
  }

  // 2) 逗号分隔
  return trimmed
    .split(',')
    .map(normalizeOrigin)
    .filter(isString)
}

/**
 * 发布静态资源（随代码发布）的物理根目录：
 * - 该目录来自 nest-cli assets 拷贝：craft-backend/static/**/* => dist/craft-backend/static/**/*
 *
 * 注意：
 * - 这里依赖 __dirname（运行在 dist 时能正确指向 dist 下的 static）
 * - 该目录属于“构建产物”，不要往这里写运行时数据
 */
export const resolvePackagedStaticRootPath = (): string => {
  return path.join(__dirname, '..', '..', '..', 'static')
}

/**
 * 运行时上传数据的物理根目录（持久化，强制由环境变量配置）：
 * - `${RUNTIME_DATA_ROOT_PATH}/upload`
 *
 * 说明：
 * - 运行时数据必须脱离 dist，避免 build/重启导致丢失
 * - 这里读取 process.env 即可（ConfigModule 已在启动时完成校验）
 */
export const resolveRuntimeUploadRootPath = (): string => {
  const raw = process.env.RUNTIME_DATA_ROOT_PATH
  if (!isString(raw) || raw.trim().length === 0) {
    // 双保险：即使未来有人绕过 ConfigModule 校验，这里也能尽早失败
    throw new Error('RUNTIME_DATA_ROOT_PATH is required')
  }

  return path.resolve(raw.trim(), 'upload')
}
```

---

### 3) 静态模块：同时挂载 `/static/upload`（运行时）与 `/static`（发布静态）
文件：`packages/craft-backend/src/common/static/static-assets.module.ts`

```ts
import { Module } from '@nestjs/common'
import { ServeStaticModule } from '@nestjs/serve-static'
import { ensureDirSync } from '@/utils/fs'
import { resolvePackagedStaticRootPath, resolveRuntimeUploadRootPath } from './static-assets.utils'
import { StaticOriginAllowMiddleware } from './static-origin-allow.middleware'

/**
 * StaticAssetsModule：
 * - /static/upload/*  => 运行时上传数据（`${RUNTIME_DATA_ROOT_PATH}/upload`）
 * - /static/*         => 随代码发布的静态资源（dist/craft-backend/static，由 assets 拷贝）
 *
 * 设计原则：
 * - dist 是构建产物：可被清空/覆盖，不能承载用户数据
 * - 运行时数据必须落在 dist 之外，并通过 ServeStatic 暴露访问
 */
@Module({
  imports: [
    ServeStaticModule.forRootAsync({
      useFactory: () => {
        // 运行时上传根目录：确保目录存在（避免首次访问/上传时才创建导致排查困难）
        const runtimeUploadRoot = resolveRuntimeUploadRootPath()
        ensureDirSync(runtimeUploadRoot)

        return [
          /**
           * 1) 运行时上传数据（更具体的路径前缀放在前面）
           * - /static/upload/** => ${RUNTIME_DATA_ROOT_PATH}/upload/**
           */
          {
            rootPath: runtimeUploadRoot,
            serveRoot: '/static/upload',
            renderPath: '/__static_render_disabled_runtime_upload__',
            useGlobalPrefix: false,
            serveStaticOptions: {
              index: false,
              dotfiles: 'deny',
              redirect: false,
              fallthrough: true,

              // 上传文件名是时间戳/缩略图是 hash，适合长缓存
              cacheControl: true,
              immutable: true,
              maxAge: '30d',

              setHeaders: (res: any) => {
                res.setHeader('X-Content-Type-Options', 'nosniff')
              },
            },
          },

          /**
           * 2) 随代码发布的静态资源（维持现状，不改名）
           * - /static/** => dist/craft-backend/static/**
           */
          {
            rootPath: resolvePackagedStaticRootPath(),
            serveRoot: '/static',
            renderPath: '/__static_render_disabled_packaged__',
            useGlobalPrefix: false,
            serveStaticOptions: {
              index: false,
              dotfiles: 'deny',
              redirect: false,
              fallthrough: true,

              cacheControl: true,
              immutable: true,
              maxAge: '30d',

              setHeaders: (res: any) => {
                res.setHeader('X-Content-Type-Options', 'nosniff')
              },
            },
          },
        ]
      },
    }),
  ],
  providers: [StaticOriginAllowMiddleware],
})
export class StaticAssetsModule {}
```

---

### 4) 上传落盘目录：写到 `${RUNTIME_DATA_ROOT_PATH}/upload/img/...`
文件：`packages/craft-backend/src/common/upload/upload.controller.ts`

```ts
import path from 'node:path'
import { Body, Controller, FileTypeValidator, HttpStatus, Logger, MaxFileSizeValidator, ParseFilePipe, Post, UploadedFile, UploadedFiles, UseGuards, UseInterceptors } from '@nestjs/common'
import { AnyFilesInterceptor, FileInterceptor } from '@nestjs/platform-express'
import { Express } from 'express'
import multer from 'multer'
import { MetaRes } from '@/common/meta/meta.decorator'
import { resolveRuntimeUploadRootPath } from '@/common/static/static-assets.utils'
import { getExtFromMimeType, IMG_BASE_DIRS, UploadService } from '@/common/upload/upload.service'
import { JwtAuthGuard } from '@/module/auth/guard/jwt-auth.guard'
import { ensureDirSync } from '@/utils/fs'

/**
 * 以“天”为单位的目录 key（epoch day）。
 * - 例：Math.floor(Date.now() / 86400000) => "20000" 这种
 * - 优点：实现极简；缺点：不如 YYYYMMDD 直观
 */
export const getUploadDayKey = (): string => {
  return String(Math.floor(Date.now() / (24 * 60 * 60 * 1000)))
}

@Controller('upload')
export class UploadController {
  private readonly logger = new Logger(UploadController.name)

  constructor(private readonly uploadService: UploadService) {}

  @Post('example')
  @MetaRes({ message: '上传文件成功' })
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(AnyFilesInterceptor())
  example(@UploadedFiles() files: Express.Multer.File[], @Body() body: object) {
    console.log('body:', body)
    this.logger.debug('已上传的文件信息')
    this.logger.debug(files)
    return files.length
  }

  @Post('img')
  @MetaRes({ message: '上传图片成功' })
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(FileInterceptor('img', {
    storage: multer.diskStorage({
      destination: (_req, _file, callback) => {
        const dayKey = getUploadDayKey()

        // 运行时上传根目录（持久化）：${RUNTIME_DATA_ROOT_PATH}/upload
        const runtimeUploadRoot = resolveRuntimeUploadRootPath()

        // 原图最终落盘：${RUNTIME_DATA_ROOT_PATH}/upload/img/<dayKey>/*
        const destAbs = path.join(runtimeUploadRoot, ...IMG_BASE_DIRS, dayKey)

        // multer 不会自动创建多级目录，这里手动创建
        ensureDirSync(destAbs)
        callback(null, destAbs)
      },
      filename: (_req, file, callback) => {
        const ext = getExtFromMimeType(file.mimetype)
        // 使用随机名避免重名；不要使用 originalname，避免奇怪字符/路径等安全问题
        const filename = `${Date.now()}${ext}`
        callback(null, filename)
      },
    }),
  }))
  async uploadFile(
    @UploadedFile(
      new ParseFilePipe({
        validators: [
          new MaxFileSizeValidator({ maxSize: 10 * 1000 * 1000 }),
          new FileTypeValidator({
            fileType: /^(image\/jpeg|image\/jpg|image\/png|image\/webp|image\/gif|image\/avif)$/,
            skipMagicNumbersValidation: true,
          }),
        ],
        errorHttpStatusCode: HttpStatus.FORBIDDEN,
      }),
    ) file: Express.Multer.File,
  ) {
    return this.uploadService.uploadImage(file)
  }
}
```

---

### 5) URL 生成：统一返回 `/static/upload/...` 两个 URL
文件：`packages/craft-backend/src/common/upload/upload.service.ts`

```ts
import fs from 'node:fs'
import path from 'node:path'
import { pipeline } from 'node:stream/promises'
import { tryCatch } from '@my-lego/shared'
import { HttpStatus, Logger } from '@nestjs/common'
import sharp from 'sharp'
import { BizException } from '@/common/error/biz.exception'
import { resolveRuntimeUploadRootPath } from '@/common/static/static-assets.utils'
import { ensureDirSync, fileExists, getSha256FromFile, safeUnlink } from '@/utils/fs'

/**
 * 从 mimetype 映射原图扩展名（用于落盘文件后缀）。
 * ext 从 mimetype 映射（更安全）
 */
export const getExtFromMimeType = (mimeType?: string): string => {
  if (mimeType === 'image/jpeg') return '.jpg'
  if (mimeType === 'image/jpg') return '.jpg'
  if (mimeType === 'image/png') return '.png'
  if (mimeType === 'image/webp') return '.webp'
  if (mimeType === 'image/gif') return '.gif'
  if (mimeType === 'image/avif') return '.avif'
  return ''
}

/**
 * 把磁盘绝对路径转成可访问的 `/static/upload` URL。
 * - 运行时文件根目录：`${RUNTIME_DATA_ROOT_PATH}/upload`
 * - 例：{runtimeUploadRoot}/img/...  => /static/upload/img/...
 */
const toRuntimeUploadStaticUrl = (runtimeUploadRootAbsPath: string, fileAbsPath: string): string => {
  const rel = path.relative(runtimeUploadRootAbsPath, fileAbsPath)
  // URL 统一用 POSIX 分隔符，避免 Windows 反斜杠
  const urlPath = rel.split(path.sep).join('/')
  return `/static/upload/${urlPath}`
}

// 原图存储目录（相对 `${RUNTIME_DATA_ROOT_PATH}/upload`）
export const IMG_BASE_DIRS = ['img'] as const
// 缩略图存储目录（相对 `${RUNTIME_DATA_ROOT_PATH}/upload`）
const THUMB_DIRS = ['thumb'] as const

export class UploadService {
  private readonly logger = new Logger(UploadService.name)

  /**
   * 上传图片，并生成缩略图
   * - 原图不做 hash 去重
   * - 缩略图按 hash 去重（同图重复上传可复用同一缩略图）
   */
  async uploadImage(file: Express.Multer.File) {
    // 1) 用 sharp 解码做“真实图片校验”（解码失败则拒绝，并删除已落盘文件）
    const [, error] = await tryCatch(sharp(file.path).metadata())
    if (error) {
      this.logger.error(error)
      await safeUnlink(file.path)
      this.logger.error('sharp 解码失败，疑似伪造/损坏图片，已删除原文件')
      throw new BizException({ errorKey: 'imageUploadFail', httpStatus: HttpStatus.BAD_REQUEST })
    }

    // 2) 计算 hash（用于缩略图命名）
    const sha256 = await getSha256FromFile(file.path)

    // 3) 生成缩略图到：${RUNTIME_DATA_ROOT_PATH}/upload/thumb/<h0h1>/<h2h3>/<sha256>_w320.webp
    // 使用 hash 分桶，避免单目录文件过多；同时移除 dayKey，实现全局去重。
    const runtimeUploadRoot = resolveRuntimeUploadRootPath()
    const shard1 = sha256.slice(0, 2)
    const shard2 = sha256.slice(2, 4)
    const thumbDirAbs = path.join(runtimeUploadRoot, ...THUMB_DIRS, shard1, shard2)
    ensureDirSync(thumbDirAbs)

    const thumbnailFilename = `${sha256.slice(4)}_w320.webp`
    const thumbnailAbsPath = path.join(thumbDirAbs, thumbnailFilename)

    const ifExist = await fileExists(thumbnailAbsPath)
    if (!ifExist) {
      this.logger.log(`${file.path} 的缩略图不存在，开始生成`)
      // 用 pipeline 做真正的流式处理（带 backpressure）
      // flags: 'wx' => 仅当文件不存在时创建，避免并发重复写入
      const readStream = fs.createReadStream(file.path)
      const writeStream = fs.createWriteStream(thumbnailAbsPath, { flags: 'wx' })
      const transform = sharp()
        .rotate() // 自动按 EXIF 修正方向
        .resize({
          width: 320,
          fit: 'inside', // 固定宽度等比缩放（高按比例自适应）
          withoutEnlargement: true, // 小图不放大，避免糊
        })
        .webp({ quality: 80 })

      const [, pipelineError] = await tryCatch(pipeline(readStream, transform, writeStream))
      if (pipelineError) {
        this.logger.error(pipelineError)
        if ((pipelineError as any).code === 'EEXIST') {
          // 并发下可能另一请求先写入成功，这里视为成功复用
        }
        else {
          // 失败时尽量清理可能残留的半成品文件
          await safeUnlink(thumbnailAbsPath)
          await safeUnlink(file.path)
          this.logger.error('生成缩略图失败，已删除原文件')
          throw pipelineError
        }
      }
    }

    // 4) 返回两个 URL（同步返回），需要前端自己拼接 origin
    const originalUrl = toRuntimeUploadStaticUrl(runtimeUploadRoot, file.path)
    const thumbnailUrl = toRuntimeUploadStaticUrl(runtimeUploadRoot, thumbnailAbsPath)
    return { originalUrl, thumbnailUrl }
  }
}
```

---

### 你需要做的运行配置
- 在 `.env.development` / `.env.production`（或你的部署环境变量）里加：

`RUNTIME_DATA_ROOT_PATH=/绝对路径/到/运行时数据根目录`

示例（开发）：
- `RUNTIME_DATA_ROOT_PATH=/Users/tylerzzheng/projects/lego/my-lego/packages/craft-backend/.data`

启动后，上传文件会写到：
- `${RUNTIME_DATA_ROOT_PATH}/upload/img/...`
- `${RUNTIME_DATA_ROOT_PATH}/upload/thumb/...`

访问：
- `/static/upload/img/...`
- `/static/upload/thumb/...`

如果你愿意，我也可以顺手把 `StaticOriginAllowMiddleware` 放开 `HEAD`（目前只允许 `GET`），避免某些客户端探测资源时被 405；你确认要不要一起做即可。

```typescript
import path from 'node:path'
import { Module } from '@nestjs/common'
import { ConfigModule as NestConfigModule } from '@nestjs/config'
import * as Joi from 'joi'

// 启动时就能发现漏配，而不是运行中报错
const validationSchema = Joi.object({
  NODE_ENV: Joi.string().valid('development', 'production').default('development'),
  PORT: Joi.number().default(3000),

  CORS: Joi.string().valid('true', 'false').default('true'),
  PREFIX: Joi.string().default('/api'),
  VERSION: Joi.string().optional(),

  LOG_ON: Joi.string().valid('true', 'false').default('true'),

  JWT_SECRET: Joi.string().required(),

  TEST_MODULE_ON: Joi.string().valid('true', 'false').default('false'),

  /* GitHub */
  GITHUB_OAUTH_CLIENT_ID: Joi.string().required(),
  GITHUB_OAUTH_CLIENT_SECRET: Joi.string().required(),
  GITHUB_OAUTH_CALLBACK_URL: Joi.string().required(),
  FRONTEND_ORIGIN: Joi.string().required(),

  /**
   * 运行时数据根目录（强制配置，必须是绝对路径）：
   * - 上传原图、缩略图等“运行时生成的数据”都会写到 `${RUNTIME_DATA_ROOT_PATH}/upload/*`
   * - 该目录必须在 dist 之外，避免 build / deleteOutDir 导致数据丢失
   *
   * 示例：
   * - macOS/Linux（开发）：/Users/xxx/projects/lego/my-lego/packages/craft-backend/.data
   * - 生产（裸机）：/var/lib/my-lego
   * - Docker：/data（再用 volume 映射到宿主机）
   */
  RUNTIME_DATA_ROOT_PATH: Joi.string()
    .required()
    .custom((val, helpers) => {
      const trimmed = String(val).trim()
      if (trimmed.length === 0) return helpers.error('any.invalid')
      if (!path.isAbsolute(trimmed)) return helpers.error('any.invalid')
      return trimmed
    }, 'RUNTIME_DATA_ROOT_PATH absolute path validation')
    .messages({
      'any.invalid': 'RUNTIME_DATA_ROOT_PATH 必须是非空的绝对路径（例如 /var/lib/my-lego）',
      'any.required': '缺少必填环境变量 RUNTIME_DATA_ROOT_PATH',
    }),

  /**
   * 静态资源允许的来源（Origin）白名单：
   * - 为空/未配置：不做任何 Origin 限制（完全放开）
   * - 配置后：仅允许白名单内的 Origin 访问 /static/* 资源（尽力而为：优先使用 Origin，其次尝试从 Referer 推导）
   *
   * 推荐配置形式：
   * - JSON 数组：["http://localhost:5173","https://your-frontend.com"]
   * - 或逗号分隔字符串：http://localhost:5173,https://your-frontend.com
   */
  STATIC_ALLOWED_ORIGINS: Joi.string().optional().allow(''),

  /**
   * Mongo 索引同步开关：
   * - true：启动时执行 Model.syncIndexes()（会删除 DB 中“Schema 未声明”的索引）
   * - false：不执行索引同步
   *
   * 默认行为在 `MongoIndexSyncService` 中实现：
   * - development：默认 true
   * - production：默认 false
   */
  MONGO_SYNC_INDEXES: Joi.string().valid('true', 'false').optional(),
})

// 指定数组时， 如果一个变量在多个文件中被找到，则以第一个为准。
const envFilePath = [`.env.${process.env.NODE_ENV || 'development'}`, '.env']

@Module({
  imports: [
    NestConfigModule.forRoot({
      envFilePath,
      isGlobal: true, // ConfigService 全局可用
      validationSchema,
    }),
  ],
})
export class ConfigModule {}
```

```typescript
import path from 'node:path'
import { isString } from '@my-lego/shared'

/**
 * 把任意 URL/Origin 字符串归一化为 `url.origin`（形如：`https://example.com`）。
 * - 非法 URL 返回 null
 * - 便于后续做“严格相等”匹配
 */
export const normalizeOrigin = (val?: unknown): string | null => {
  if (!isString(val)) return null
  const trimmed = val.trim()
  if (trimmed.length === 0) return null

  try {
    return new URL(trimmed).origin.toLowerCase()
  }
  catch {
    return null
  }
}

/**
 * 从环境变量解析允许的 Origin 列表。
 *
 * 设计目标：
 * - 支持 JSON 数组：["http://localhost:5173","https://your-frontend.com"]
 * - 支持逗号分隔：http://localhost:5173,https://your-frontend.com
 * - 空值/解析失败：返回空数组（代表“不做任何 Origin 限制”）
 */
export const parseStaticAllowedOrigins = (rawValue?: string): string[] => {
  if (typeof rawValue !== 'string') return []
  const trimmed = rawValue.trim()
  if (trimmed.length === 0) return []

  // 1) JSON 数组
  if (trimmed.startsWith('[')) {
    try {
      const parsed = JSON.parse(trimmed) as unknown
      if (!Array.isArray(parsed)) return []

      return parsed
        .map(normalizeOrigin)
        .filter(isString)
    }
    catch {
      // JSON 不合法：按“无配置”处理（完全放开）
      return []
    }
  }

  // 2) 逗号分隔
  return trimmed
    .split(',')
    .map(normalizeOrigin)
    .filter(isString)
}

/**
 * 发布静态资源（随代码发布）的物理根目录：
 * - 该目录来自 nest-cli assets 拷贝：craft-backend/static/**/* => dist/craft-backend/static/**/*
 *
 * 注意：
 * - 这里依赖 __dirname（运行在 dist 时能正确指向 dist 下的 static）
 * - 该目录属于“构建产物”，不要往这里写运行时数据
 */
export const resolvePackagedStaticRootPath = (): string => {
  return path.join(__dirname, '..', '..', '..', 'static')
}

/**
 * 运行时上传数据的物理根目录（持久化，强制由环境变量配置）：
 * - `${RUNTIME_DATA_ROOT_PATH}/upload`
 *
 * 说明：
 * - 运行时数据必须脱离 dist，避免 build/重启导致丢失
 * - 这里读取 process.env 即可（ConfigModule 已在启动时完成校验）
 */
export const resolveRuntimeUploadRootPath = (): string => {
  const raw = process.env.RUNTIME_DATA_ROOT_PATH
  if (!isString(raw) || raw.trim().length === 0) {
    // 双保险：即使未来有人绕过 ConfigModule 校验，这里也能尽早失败
    throw new Error('RUNTIME_DATA_ROOT_PATH is required')
  }

  return path.resolve(raw.trim(), 'upload')
}
```

```typescript
import { Module } from '@nestjs/common'
import { ServeStaticModule } from '@nestjs/serve-static'
import { ensureDirSync } from '@/utils/fs'
import { resolvePackagedStaticRootPath, resolveRuntimeUploadRootPath } from './static-assets.utils'
import { StaticOriginAllowMiddleware } from './static-origin-allow.middleware'

/**
 * StaticAssetsModule：
 * - /static/upload/*  => 运行时上传数据（`${RUNTIME_DATA_ROOT_PATH}/upload`）
 * - /static/*         => 随代码发布的静态资源（dist/craft-backend/static，由 assets 拷贝）
 *
 * 设计原则：
 * - dist 是构建产物：可被清空/覆盖，不能承载用户数据
 * - 运行时数据必须落在 dist 之外，并通过 ServeStatic 暴露访问
 */
@Module({
  imports: [
    ServeStaticModule.forRootAsync({
      useFactory: () => {
        // 运行时上传根目录：确保目录存在（避免首次访问/上传时才创建导致排查困难）
        const runtimeUploadRoot = resolveRuntimeUploadRootPath()
        ensureDirSync(runtimeUploadRoot)

        return [
          /**
           * 1) 运行时上传数据（更具体的路径前缀放在前面）
           * - /static/upload/** => ${RUNTIME_DATA_ROOT_PATH}/upload/**
           */
          {
            rootPath: runtimeUploadRoot,
            serveRoot: '/static/upload',
            renderPath: '/__static_render_disabled_runtime_upload__',
            useGlobalPrefix: false,
            serveStaticOptions: {
              index: false,
              dotfiles: 'deny',
              redirect: false,
              fallthrough: true,

              // 上传文件名是时间戳/缩略图是 hash，适合长缓存
              cacheControl: true,
              immutable: true,
              maxAge: '30d',

              setHeaders: (res: any) => {
                res.setHeader('X-Content-Type-Options', 'nosniff')
              },
            },
          },

          /**
           * 2) 随代码发布的静态资源（维持现状，不改名）
           * - /static/** => dist/craft-backend/static/**
           */
          {
            rootPath: resolvePackagedStaticRootPath(),
            serveRoot: '/static',
            renderPath: '/__static_render_disabled_packaged__',
            useGlobalPrefix: false,
            serveStaticOptions: {
              index: false,
              dotfiles: 'deny',
              redirect: false,
              fallthrough: true,

              cacheControl: true,
              immutable: true,
              maxAge: '30d',

              setHeaders: (res: any) => {
                res.setHeader('X-Content-Type-Options', 'nosniff')
              },
            },
          },
        ]
      },
    }),
  ],
  providers: [StaticOriginAllowMiddleware],
})
export class StaticAssetsModule {}
```

```typescript
import path from 'node:path'
import { Body, Controller, FileTypeValidator, HttpStatus, Logger, MaxFileSizeValidator, ParseFilePipe, Post, UploadedFile, UploadedFiles, UseGuards, UseInterceptors } from '@nestjs/common'
import { AnyFilesInterceptor, FileInterceptor } from '@nestjs/platform-express'
import { Express } from 'express'
import multer from 'multer'
import { MetaRes } from '@/common/meta/meta.decorator'
import { resolveRuntimeUploadRootPath } from '@/common/static/static-assets.utils'
import { getExtFromMimeType, IMG_BASE_DIRS, UploadService } from '@/common/upload/upload.service'
import { JwtAuthGuard } from '@/module/auth/guard/jwt-auth.guard'
import { ensureDirSync } from '@/utils/fs'

/**
 * 以“天”为单位的目录 key（epoch day）。
 * - 例：Math.floor(Date.now() / 86400000) => "20000" 这种
 * - 优点：实现极简；缺点：不如 YYYYMMDD 直观
 */
export const getUploadDayKey = (): string => {
  return String(Math.floor(Date.now() / (24 * 60 * 60 * 1000)))
}

@Controller('upload')
export class UploadController {
  private readonly logger = new Logger(UploadController.name)

  constructor(private readonly uploadService: UploadService) {}

  @Post('example')
  @MetaRes({ message: '上传文件成功' })
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(AnyFilesInterceptor())
  example(@UploadedFiles() files: Express.Multer.File[], @Body() body: object) {
    console.log('body:', body)
    this.logger.debug('已上传的文件信息')
    this.logger.debug(files)
    return files.length
  }

  @Post('img')
  @MetaRes({ message: '上传图片成功' })
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(FileInterceptor('img', {
    storage: multer.diskStorage({
      destination: (_req, _file, callback) => {
        const dayKey = getUploadDayKey()

        // 运行时上传根目录（持久化）：${RUNTIME_DATA_ROOT_PATH}/upload
        const runtimeUploadRoot = resolveRuntimeUploadRootPath()

        // 原图最终落盘：${RUNTIME_DATA_ROOT_PATH}/upload/img/<dayKey>/*
        const destAbs = path.join(runtimeUploadRoot, ...IMG_BASE_DIRS, dayKey)

        // multer 不会自动创建多级目录，这里手动创建
        ensureDirSync(destAbs)
        callback(null, destAbs)
      },
      filename: (_req, file, callback) => {
        const ext = getExtFromMimeType(file.mimetype)
        // 使用随机名避免重名；不要使用 originalname，避免奇怪字符/路径等安全问题
        const filename = `${Date.now()}${ext}`
        callback(null, filename)
      },
    }),
  }))
  async uploadFile(
    @UploadedFile(
      new ParseFilePipe({
        validators: [
          new MaxFileSizeValidator({ maxSize: 10 * 1000 * 1000 }),
          new FileTypeValidator({
            fileType: /^(image\/jpeg|image\/jpg|image\/png|image\/webp|image\/gif|image\/avif)$/,
            skipMagicNumbersValidation: true,
          }),
        ],
        errorHttpStatusCode: HttpStatus.FORBIDDEN,
      }),
    ) file: Express.Multer.File,
  ) {
    return this.uploadService.uploadImage(file)
  }
}
```

```typescript
import fs from 'node:fs'
import path from 'node:path'
import { pipeline } from 'node:stream/promises'
import { tryCatch } from '@my-lego/shared'
import { HttpStatus, Logger } from '@nestjs/common'
import sharp from 'sharp'
import { BizException } from '@/common/error/biz.exception'
import { resolveRuntimeUploadRootPath } from '@/common/static/static-assets.utils'
import { ensureDirSync, fileExists, getSha256FromFile, safeUnlink } from '@/utils/fs'

/**
 * 从 mimetype 映射原图扩展名（用于落盘文件后缀）。
 * ext 从 mimetype 映射（更安全）
 */
export const getExtFromMimeType = (mimeType?: string): string => {
  if (mimeType === 'image/jpeg') return '.jpg'
  if (mimeType === 'image/jpg') return '.jpg'
  if (mimeType === 'image/png') return '.png'
  if (mimeType === 'image/webp') return '.webp'
  if (mimeType === 'image/gif') return '.gif'
  if (mimeType === 'image/avif') return '.avif'
  return ''
}

/**
 * 把磁盘绝对路径转成可访问的 `/static/upload` URL。
 * - 运行时文件根目录：`${RUNTIME_DATA_ROOT_PATH}/upload`
 * - 例：{runtimeUploadRoot}/img/...  => /static/upload/img/...
 */
const toRuntimeUploadStaticUrl = (runtimeUploadRootAbsPath: string, fileAbsPath: string): string => {
  const rel = path.relative(runtimeUploadRootAbsPath, fileAbsPath)
  // URL 统一用 POSIX 分隔符，避免 Windows 反斜杠
  const urlPath = rel.split(path.sep).join('/')
  return `/static/upload/${urlPath}`
}

// 原图存储目录（相对 `${RUNTIME_DATA_ROOT_PATH}/upload`）
export const IMG_BASE_DIRS = ['img'] as const
// 缩略图存储目录（相对 `${RUNTIME_DATA_ROOT_PATH}/upload`）
const THUMB_DIRS = ['thumb'] as const

export class UploadService {
  private readonly logger = new Logger(UploadService.name)

  /**
   * 上传图片，并生成缩略图
   * - 原图不做 hash 去重
   * - 缩略图按 hash 去重（同图重复上传可复用同一缩略图）
   */
  async uploadImage(file: Express.Multer.File) {
    // 1) 用 sharp 解码做“真实图片校验”（解码失败则拒绝，并删除已落盘文件）
    const [, error] = await tryCatch(sharp(file.path).metadata())
    if (error) {
      this.logger.error(error)
      await safeUnlink(file.path)
      this.logger.error('sharp 解码失败，疑似伪造/损坏图片，已删除原文件')
      throw new BizException({ errorKey: 'imageUploadFail', httpStatus: HttpStatus.BAD_REQUEST })
    }

    // 2) 计算 hash（用于缩略图命名）
    const sha256 = await getSha256FromFile(file.path)

    // 3) 生成缩略图到：${RUNTIME_DATA_ROOT_PATH}/upload/thumb/<h0h1>/<h2h3>/<sha256>_w320.webp
    // 使用 hash 分桶，避免单目录文件过多；同时移除 dayKey，实现全局去重。
    const runtimeUploadRoot = resolveRuntimeUploadRootPath()
    const shard1 = sha256.slice(0, 2)
    const shard2 = sha256.slice(2, 4)
    const thumbDirAbs = path.join(runtimeUploadRoot, ...THUMB_DIRS, shard1, shard2)
    ensureDirSync(thumbDirAbs)

    const thumbnailFilename = `${sha256.slice(4)}_w320.webp`
    const thumbnailAbsPath = path.join(thumbDirAbs, thumbnailFilename)

    const ifExist = await fileExists(thumbnailAbsPath)
    if (!ifExist) {
      this.logger.log(`${file.path} 的缩略图不存在，开始生成`)
      // 用 pipeline 做真正的流式处理（带 backpressure）
      // flags: 'wx' => 仅当文件不存在时创建，避免并发重复写入
      const readStream = fs.createReadStream(file.path)
      const writeStream = fs.createWriteStream(thumbnailAbsPath, { flags: 'wx' })
      const transform = sharp()
        .rotate() // 自动按 EXIF 修正方向
        .resize({
          width: 320,
          fit: 'inside', // 固定宽度等比缩放（高按比例自适应）
          withoutEnlargement: true, // 小图不放大，避免糊
        })
        .webp({ quality: 80 })

      const [, pipelineError] = await tryCatch(pipeline(readStream, transform, writeStream))
      if (pipelineError) {
        this.logger.error(pipelineError)
        if ((pipelineError as any).code === 'EEXIST') {
          // 并发下可能另一请求先写入成功，这里视为成功复用
        }
        else {
          // 失败时尽量清理可能残留的半成品文件
          await safeUnlink(thumbnailAbsPath)
          await safeUnlink(file.path)
          this.logger.error('生成缩略图失败，已删除原文件')
          throw pipelineError
        }
      }
    }

    // 4) 返回两个 URL（同步返回），需要前端自己拼接 origin
    const originalUrl = toRuntimeUploadStaticUrl(runtimeUploadRoot, file.path)
    const thumbnailUrl = toRuntimeUploadStaticUrl(runtimeUploadRoot, thumbnailAbsPath)
    return { originalUrl, thumbnailUrl }
  }
}
```

